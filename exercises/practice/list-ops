import
  std / [unittest, sugar]

import
  list_ops

suite "append entries to a list and return the new list":
  test "empty lists":
    check append(newSeq[int](), newSeq[int]()) == newSeq[int]()
  test "list to empty list":
    check append(newSeq[int](), @[1, 2, 3, 4]) == @[1, 2, 3, 4]
  test "empty list to list":
    check append(@[1, 2, 3, 4], newSeq[int]()) == @[1, 2, 3, 4]
  test "non-empty lists":
    check append(@[1, 2], @[2, 3, 4, 5]) == @[1, 2, 2, 3, 4, 5]
suite "concatenate a list of lists":
  test "empty list":
    check concat(newSeq[int]()) == newSeq[int]()
  test "list of lists":
    check concat(@[@[1, 2], @[3], newSeq[int](), @[4, 5, 6]]) ==
        @[1, 2, 3, 4, 5, 6]
  test "list of nested lists":
    check concat(@[@[@[1], @[2]], @[@[3]], @[newSeq[int]()], @[@[4, 5, 6]]]) ==
        @[@[1], @[2], @[3], newSeq[int](), @[4, 5, 6]]
suite "filter list returning only values that satisfy the filter function":
  test "empty list":
    check filter(newSeq[int](), (x) => x mod 2 == 1) == newSeq[int]()
  test "non-empty list":
    check filter(@[1, 2, 3, 5], (x) => x mod 2 == 1) == @[1, 3, 5]
suite "returns the length of a list":
  test "empty list":
    check length(newSeq[int]()) == 0
  test "non-empty list":
    check length(@[1, 2, 3, 4]) == 4
suite "return a list of elements whose values equal the list value transformed by the mapping function":
  test "empty list":
    check map(newSeq[int](), (x) => x + 1) == newSeq[int]()
  test "non-empty list":
    check map(@[1, 3, 5, 7], (x) => x + 1) == @[2, 4, 6, 8]
suite "folds (reduces) the given list from the left with a function":
  test "empty list":
    check foldl(newSeq[int](), 2, (x, y) => x * y) == 2
  test "direction independent function applied to non-empty list":
    check foldl(@[1, 2, 3, 4], 5, (x, y) => x + y) == 15
  test "direction dependent function applied to non-empty list":
    check foldl(@[2, 5], 5, (x, y) => x / y) == 0
  test "empty list":
    check foldl(newSeq[int](), 2, (acc, el) => el * acc) == 2
  test "direction independent function applied to non-empty list":
    check foldl(@[1, 2, 3, 4], 5, (acc, el) => el + acc) == 15
  test "direction dependent function applied to non-empty list":
    check foldl(@[1, 2, 3, 4], 24, (acc, el) => el / acc) == 64
suite "folds (reduces) the given list from the right with a function":
  test "empty list":
    check foldr(newSeq[int](), 2, (x, y) => x * y) == 2
  test "direction independent function applied to non-empty list":
    check foldr(@[1, 2, 3, 4], 5, (x, y) => x + y) == 15
  test "direction dependent function applied to non-empty list":
    check foldr(@[2, 5], 5, (x, y) => x / y) == 2
  test "empty list":
    check foldr(newSeq[int](), 2, (acc, el) => el * acc) == 2
  test "direction independent function applied to non-empty list":
    check foldr(@[1, 2, 3, 4], 5, (acc, el) => el + acc) == 15
  test "direction dependent function applied to non-empty list":
    check foldr(@[1, 2, 3, 4], 24, (acc, el) => el / acc) == 9
suite "reverse the elements of the list":
  test "empty list":
    check reverse(newSeq[int]()) == newSeq[int]()
  test "non-empty list":
    check reverse(@[1, 3, 5, 7]) == @[7, 5, 3, 1]
  test "list of lists is not flattened":
    check reverse(@[@[1, 2], @[3], newSeq[int](), @[4, 5, 6]]) ==
        @[@[4, 5, 6], newSeq[int](), @[3], @[1, 2]]
